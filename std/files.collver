// While these procedures may seem useless, they are here to wrap the functions and include some documentation so that the developer is not completely confused.
// In addition, error handling will eventually be wrapped into these, so they aren't completely useless

// NOTE: Arguments shown in this section's documentation comments are in the order of bottom to top of the stack.
//       For example, open accepts its arguments in the order: [<BOTTOM OF STACK> *file_path, flags <TOP OF STACK>].
//       Keep this in mind when syscalls magically fail, you probably just put the arguments in the wrong order.

// Required flags - at least one of these bits must be present
const O_RDONLY 0 end
const O_WRONLY 1 end
const O_RDWR   2 end

// Non-required flags
const O_CLOEXEC   16777216 end
const O_CREAT     512 end
const O_DIRECTORY 1048576 end
const O_EXCL      2048 end
const O_NOCTTY    131072 end
const O_NOFOLLOW  256 end
const O_TRUNC     1024 end
// TODO: Implement the rest of these constants https://man7.org/linux/man-pages/man2/open.2.html

// int open(char *fp, int flags)
proc sys_open // ptr int -> int
  // Open a file (returns a file descriptor)
  // Arguments:
  //  - File path - A char pointer (char*)
  //  - Flags     - An integer: must be one of { O_RDONLY, O_WRONLY, O_RDWR },
  //                optionally bitwised or-ed with any O_{name} constants
  // Return value:
  //  - Success: File descriptor of opened file (int)
  //  - Failure: `-1`, `errno` is set
  // For more information, see https://man7.org/linux/man-pages/man2/open.2.html

  ll_open
end

// int close(int fd)
proc sys_close // int -> int
  // Close a file
  // Arguments:
  //  - File descriptor - file descriptor of the file to be closed (int)
  // Return value:
  //  - Success: `0`
  //  - Failure: `-1`, `errno` is set

  ll_close
end

const SEEK_SET 0 end
const SEEK_CUR 1 end
const SEEK_END 2 end

// int lseek(int fd, int offset, int whence)
proc sys_lseek // int int int -> int
  // Reposition file offset (move the `cursor` around in an opened file)
  // Arguments:
  //  - File descriptor - file descriptor of file that is being seeked within (int)
  //  - Offset          - A number of bytes (varies based on `whence`'s value) (int)
  //  - Whence          - One of { SEEK_SET, SEEK_CUR, SEEK_END} denoting which type of repositioning of the cursor should occur:
  //     - SEEK_SET - The file offset is set to `offset` bytes
  //     - SEEK_CUR - The file offset is set to its current location plus `offset` bytes
  //     - SEEK_END - The file offset is set to the size of the file plus `offset` bytes
  // Return value:
  //  - Success: The resulting offset value (location in file) after the seek occurs (measured in bytes, from the beginning of the file) (int)
  //  - Failure: `-1`, `errno` is set
  // For more information, see https://man7.org/linux/man-pages/man2/lseek.2.html

  ll_lseek
end

proc fdtell // int -> int
  // Get the current offset in a file, given a file descriptor
  // Arguments:
  //  - File descriptor - file descriptor of the file whose offset is being gotten (int)
  // Return value:
  //  - Success: The offset value (location in file) in bytes (from the start of the file) (int)
  //  - Failure: `-1`, `errno` is set (error conditions come from the syscall `lseek`)

  0 SEEK_CUR sys_lseek
end

proc fdsize // int -> int
  // Find the size of a file (in bytes) given a file descriptor
  // This procedure does not modify the current offset of the file (it modifies it with lseek but restores it afterwards)
  // Arguments:
  //  - File descriptor - Which file should be sized (int)
  // Return value:
  //  - Success: The size of the file (in bytes)
  //  - Failure: `-1`, `errno` is set (error conditions come from the syscall `lseek`)
  memory offset_orig sizeof(int) end

  dup  fdtell offset_orig !64
  dup  0 SEEK_END sys_lseek
  swap offset_orig @64 SEEK_SET sys_lseek drop
end

// int read(int fd, ptr buf, int count)
proc sys_read // int ptr int -> int
  // Read `count` bytes from file descriptor `fd` into memory, starting at `ptr`
  // This procedure moves the offset of the file descriptor forward by `count` bytes
  // Arguments:
  //  - File descriptor - file descriptor of file that is being read (int)
  //  - Buffer          - A pointer to the start of the buffer that the data will be written to (ptr)
  //  - Count           - The number of bytes to be read (int)
  // Return value:
  //  - Success: The number of bytes read from the file (`0` indicates EOF). Sometimes, fewer bytes than were requested are actually read, this is not an error.
  //  - Failure: `-1`, `errno` is set
  // For more information, see https://man7.org/linux/man-pages/man2/read.2.html

  ll_read
end

proc fd_to_str // int -> ptr
  // Given a file descriptor, return a new (null terminated) string
  // This procedure takes a file descriptor, resets its offset to 0, calculates the size, allocates that many byte + 1, reads the whole file, and then sets the last byte to 0 (to null terminate the string).
  // This procedure will leave the offset of the file at the end of the file.
  // IMPORTANT: This procedure panics if the sys_read call doesn't read the entire file in one attempt. This is not necessary, and it will be fixed later.
  memory size sizeof(int) end // = fdsize(fd)
  memory bufptr sizeof(ptr) end // = bufptr

  dup 0 SEEK_SET sys_lseek drop
  dup fdsize dup size !64
  1 + salloc bufptr !64
  bufptr @64 size @64 sys_read
  if dup size @64 != do
    "ERROR: Failed to read file into memory\n" puts
    "File size: " puts size @64 print
    "Bytes read: " puts print
    1 exit
    // TODO: Make this procedure simply handle not reading the whole file, instead of panicking
  end
  0 bufptr @64 size @64 + !8
  bufptr @64
end

proc fp_to_str // ptr -> ptr
  // Given a pointer to a string (the path to the file), create a string in memory containing the contents of the file, and free the file path string
  memory fp_str sizeof(ptr) end
  memory fd sizeof(int) end
  fp_str !64
  fp_str @64 O_RDONLY sys_open fd !64
  fd @64 fd_to_str
  fd @64 sys_close drop
  fp_str @64 free
end
