// CONSTANTS

const sizeof(byte) 1 end
const sizeof(int) sizeof(byte) 8 * end
const sizeof(ptr) sizeof(int) end

// STACK MANIPULATION

proc swap // a b -> b a
  memory a 8 end
  memory b 8 end
  b !64
  a !64
  b @64
  a @64
end

proc over // a b -> a b a
  memory a 8 end
  memory b 8 end
  b !64
  a !64
  a @64
  b @64
  a @64
end

// MEMORY MANIPULATION

proc salloc // int -> ptr
  // Works exactly like the `alloc` intrinsic, except that it handles a failure to allocate the memory
  memory size sizeof(int) end
  dup size !64 // Leave the size on the stack

  alloc

  dup if 0 = do // Check if the pointer returned is 0 (indicates a failure in the malloc function)
    "ERROR: Failed to allocate memory.\nAttempted size of allocated memory: " puts size @64 print
    "Errno: " puts get_errno print
    1 exit
  end // Because of the `dup` before the if, the pointer is still on the stack after this if
end

proc inc64 // ptr ->
  // Given a pointer to an i64, increment the value stored there
  dup
  @64
  1 +
  swap // pointer comes second for !
  !64
end

proc dec64 // ptr ->
  // Given a pointer to an i64, decrement the value stored there
  dup
  @64
  1 -
  swap // pointer comes second for !
  !64
end

proc memcpy // size src dst ->
  // Copies `size` number of bytes from address `src` to address `dst`
  memory size 8 end
  memory src 8 end
  memory dst 8 end
  dst !64
  src !64
  size !64

  0 while dup size @64 < do
    dup  src @64 + @8
    over dst @64 + !8
    1 +
  end drop
end

// STRING MANIPULATION

proc strlen // ptr -> int
  // Given a pointer to a string, return its length
  // NOTE: Only works on null-terminated strings (string literals are null-terminated, but strings created at runtime may not be, so be careful)
  memory len 8 end
  0 len !64

  while dup len @64 +  @8 do
     len inc64
  end drop

  len @64
end

proc strcpy // src -> ptr
  // Given a pointer to a string, make a copy of it, returning the pointer to the new string
  memory src 8 end
  memory len 8 end
  memory dst 8 end
  // src = src
  // len = len(src)
  // dst = dst

  dup src !64 // Keep src on the stack for the next step
  strlen dup len !64 // Keep len(src) on the stack for the next step
  alloc dst !64
  len @64 src @64 dst @64 memcpy
  dst @64 // 'return' the destination pointer
end

proc strconcat // str1 str2 -> str3
  // Concatenate two strings, returning the pointer to the new string
  memory str1 sizeof(ptr) end
  memory len_str1 sizeof(int) end
  memory str2 sizeof(ptr) end
  memory len_str2 sizeof(int) end
  memory dst sizeof(ptr) end
  dup str2 !64 strlen len_str2 !64 // Store the length and pointer to str2 in memory
  dup str1 !64 strlen len_str1 !64 // Store the length and pointer to str1 in memory
  len_str1 @64 len_str2 @64 + 1 + alloc dst !64 // Sum the lengths of the two strings and allocate that many bytes, storing the pointer in dst (adding 1 to null terminate)
  len_str1 @64 str1 @64 dst @64 memcpy // Copy str1 to the beginning of the new memory (memcpy requires a length so we need len_str1 at the beginning)
  len_str2 @64 str2 @64 dst @64 len_str1 @64 + memcpy // Add the length of str1 to the pointer and copy str2 to there
  dst @64 len_str1 @64 len_str2 @64 + + 0 swap !8 // Write a `0` at the end, null-terminating the new string
  dst @64 // Return the pointer to the new, concatenated string
end

proc strconcat_d // str1 str2 -> str3
  // Exact same as for strconcat, but it frees the original two strings afterwards
  // NOTE: ONLY FOR STRINGS THAT HAVE BEEN DYNAMICALLY ALLOCATED WITH THE `alloc` WORD
  memory str2 sizeof(ptr) end
  memory str1 sizeof(ptr) end
  str2 !64
  dup str1 !64
  str2 @64
  strconcat
  str1 @64 free
  str2 @64 free
end
